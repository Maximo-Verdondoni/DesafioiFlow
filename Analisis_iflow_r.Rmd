---
title: "analisis iflow"
output: html_document
date: "2024-10-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Carga del CSV

```{r}
library(tidyverse)
df <- read_csv('C://Users//anapa//OneDrive//Escritorio//facu//tdii//DesafioiFlow//iFlowDatos_Limpios.csv') 
library(dplyr)
glimpse(df)
```

## Creacion de Demora Planificada

```{r}
mutate(Demora_Planificada = as.numeric(difftime(VisitaHora_Inicio, VisitaPlanificadaHora, units = "mins"))) 
df
```

## Comparacion de las Demoras

```{r}
# Comparar la demora planificada por cliente
ggplot(df, aes(x = factor(cliente), y = Demora_Planificada)) +
  geom_boxplot() +
  labs(title = "Demora Planificada por Cliente", x = "Cliente", y = "Demora Planificada (minutos)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```
```{r}
# Distribución de la demora planificada
ggplot(df, aes(x = Demora_Planificada)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "black") +
  labs(title = "Distribución de la Demora Planificada", x = "Demora Planificada (minutos)", y = "Cantidad")

```

```{r}
# Demora planificada promedio por municipio
df %>%
  group_by(municipio) %>%
  summarize(mean_delay = mean(Demora_Planificada, na.rm = TRUE)) %>%
  ggplot(aes(x = reorder(municipio, mean_delay), y = mean_delay)) +
  geom_col(fill = "steelblue") +
  labs(title = "Demora Planificada Promedio por Municipio", x = "Municipio", y = "Demora Promedio (minutos)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```
```{r}
# Demora planificada promedio por día de la semana
df %>%
  group_by(VisitaPlanificadaDia) %>%
  summarize(mean_delay = mean(Demora_Planificada, na.rm = TRUE)) %>%
  ggplot(aes(x = reorder(VisitaPlanificadaDia, mean_delay), y = mean_delay)) +
  geom_col(fill = "purple") +
  labs(title = "Demora Planificada Promedio por Día de la Semana", x = "Día de la Semana", y = "Demora Promedio (minutos)")

```

```{r}
# Demora planificada por hora de la visita planificada (redondeado a la hora más cercana)
df %>%
  mutate(Hora = hour(VisitaPlanificadaHora)) %>%
  group_by(Hora) %>%
  summarize(mean_delay = mean(Demora_Planificada, na.rm = TRUE)) %>%
  ggplot(aes(x = Hora, y = mean_delay)) +
  geom_line(color = "darkgreen") +
  geom_point(color = "darkgreen") +
  labs(title = "Demora Planificada Promedio por Hora de Visita Planificada", x = "Hora de Visita Planificada", y = "Demora Promedio (minutos)")

```

```{r}
# Demora planificada por peso
ggplot(df, aes(x = Peso, y = Demora_Planificada)) +
  geom_point(alpha = 0.6) +
  labs(title = "Demora Planificada por Peso", x = "Peso", y = "Demora Planificada (minutos)")

```

## Distancia a los Centros de Distribucion
```{r}
#Instalamos el paquete osrm que nos permitira calculares distncia en base a los modelos de Open Street Map

# install.packages('osrm')
library(osrm)

#Definimos las coordenadas para cada centro de distribuicion

centro_pablo_nogues <- c(lon = -58.69417, lat=-34.48175)
centro_garin <- c(lon= -58.72217, lat=-34.42639)
centro_tortuguitas <- c(lon= -58.72749, lat =-34.45853)

```

```{r}
library(dplyr)

options(osrm.server = "https://router.project-osrm.org/")

# Función corregida con manejo de errores
get_distance <- function(longitud, latitud, point) {
  # Chequear coordenadas válidas
  if (is.na(longitud) | is.na(latitud)) return(NA)

  # Definir origen y destino como data frames con columnas lon y lat
  src <- data.frame(lon = longitud, lat = latitud)
  dst <- data.frame(lon = point["lon"], lat = point["lat"])

  # Intentar calcular la distancia usando tryCatch para manejar errores
  result <- tryCatch({
    osrmRoute(src = src, dst = dst)
  }, error = function(e) {
    message("Error calculating distance: ", e)
    return(NULL)
  })

  # Verificar si result es NULL
  if (is.null(result)) return(NA)

  # Pasar la distancia a km si se obtiene un resultado válido
  return(result$distance)
}


# Mutate the dataset to add a new column 'Distancia_a_Punto1'
df_distancias <- tail(df,300) %>%
  rowwise() %>%
  mutate(Garin = get_distance(longitud, latitud, centro_garin),
         Pablo_Nogues = get_distance(longitud, latitud, centro_pablo_nogues),
         Tortuguitas = get_distance(longitud, latitud, centro_tortuguitas)) %>%
  ungroup()

# Check the updated dataframe
df_distancias
```

## Calculo centro distribucion mas cercano

```{r}
df_distancias <- df_distancias %>%
  mutate(
    # Calcular la distancia mínima entre los centros
    Distancia_Minima = pmin(Garin, Pablo_Nogues, Tortuguitas, na.rm = TRUE),
    
    # Asignar el nombre del centro de distribución más cercano basado en la distancia mínima
    Cercano = case_when(
      Garin == Distancia_Minima ~ "Garin",
      Pablo_Nogues == Distancia_Minima ~ "Pablo_Nogues",
      Tortuguitas == Distancia_Minima ~ "Tortuguitas",
      TRUE ~ NA_character_  # En caso de que haya un problema o NA
    )
  )

df_distancias
```
```{r}

library(leaflet)
library(dplyr)

# Crear el mapa usando leaflet
mapa_leaflet <- leaflet(df_distancias) %>%
  # Establecer la vista centrada en la provincia de Buenos Aires
  setView(lng = -58.5, lat = -34.6, zoom = 10) %>%
  
  # Añadir el mapa base de OpenStreetMap
  addTiles() %>%
  
  # Añadir los puntos de las direcciones, coloreados por el centro más cercano
  addCircleMarkers(
    ~longitud, ~latitud, 
    color = ~case_when(
      Cercano == "Garin" ~ "red",
      Cercano == "Pablo_Nogues" ~ "blue",
      Cercano == "Tortuguitas" ~ "green"
    ),
    radius = 4, fillOpacity = 0.8, stroke = FALSE, 
    label = ~paste("Centro cercano:", Cercano)  # Etiquetas mostrando el centro más cercano
  ) %>%
  
  # Añadir una leyenda
  addLegend(
    "bottomright", 
    colors = c("red", "blue", "green"), 
    labels = c("Garin", "Pablo Nogues", "Tortuguitas"), 
    title = "Centro más cercano"
  )

# Mostrar el mapa
mapa_leaflet


```